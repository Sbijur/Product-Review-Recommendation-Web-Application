# -*- coding: utf-8 -*-
"""Copy of New_Product_Recommendation_Using_Cosine_KNN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BqVqsM5xlYywGmqKCWz04nodTPwVIdZQ
"""

def hello():
  print("Hello")

from google.colab import drive

drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import csv
import os
from sklearn import svm
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
import warnings, string
warnings.filterwarnings('ignore')
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import nltk
from nltk.corpus import stopwords
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer
from sklearn.pipeline import Pipeline
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import VotingClassifier
nltk.download('stopwords')
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

"""Loading and Reading the Dataset"""

df=pd.read_csv("/content/drive/MyDrive/AI Models/Customer_Id_Data.csv",encoding='unicode_escape')



# Write the updated DataFrame back to a CSV file
df.to_csv('updated_file.csv', index=False)
df.head(10)

# Define a mapping between product types and unique identifiers
product_type_mapping = {
    'Smartphones & Basic Mobiles': 1,
    'Laptops': 2,
    'Computers & Accessories': 3,
    'Televisions':4,
    'Cameras & Photography':5,
    'Air Conditioners':6,
    'Large Appliances':7,
    'Washing Machines & Dryers':8,
    'Hi-Fi & Home Audio Speakers':9,
    'Mobile Phone Chargers':10,
    'Wearable Technology':11,
    'Audio Headphones':12,
    'Toy Vehicles':13,
    'Portable Computer Bags & Sleeves':14,
    'Grocery & Gourmet Foods':15
    # Add more mappings if needed
}

# Add a new column 'Product Type ID' to the dataset based on the mapping
df['Product_Type_ID'] = df['categories'].map(product_type_mapping)

# Save the updated dataset with the new column
df.to_csv("updated_dataset.csv", index=False)  # Replace "updated_dataset.csv" with the desired output file path


"""Implementing the Hybrid Model using TF-IDF Vectorizer and KNN Algorithm"""

import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import NearestNeighbors

# Implement content-based filtering
tfidf_vectorizer = TfidfVectorizer()
product_features = tfidf_vectorizer.fit_transform(df['categories'] + str(df['Product_Type_ID']))

# Implement collaborative filtering
ratings = pd.DataFrame({'customer_id	': df['customer_id'], 'Product_Type_ID': df['Product_Type_ID'], 'Rating': 1})
pivot_table = ratings.pivot_table(index='customer_id	', columns='Product_Type_ID', values='Rating', fill_value=0)

knn_model = NearestNeighbors(metric='cosine', algorithm='brute')
knn_model.fit(pivot_table)

def product_id(id):
  dic = {
    'Smartphones & Basic Mobiles': 1,
    'Laptops': 2,
    'Computers & Accessories': 3,
    'Televisions':4,
    'Cameras & Photography':5,
    'Air Conditioners':6,
    'Large Appliances':7,
    'Washing Machines & Dryers':8,
    'Hi-Fi & Home Audio Speakers':9,
    'Mobile Phone Chargers':10,
    'Wearable Technology':11,
    'Audio Headphones':12,
    'Toy Vehicles':13,
    'Portable Computer Bags & Sleeves':14,
    'Grocery & Gourmet Foods':15
    # Add more mappings if needed
}
  value = {i for i in dic if dic[i]==id}
  if(value==set()):
      value=" "
  return value

"""Hybrid Recommendation Model Function Using TF-IDF and KNN Algorithm, by Implementing Hybrid Indices and Hybrid Scores"""

def remove_space(p):
  c=int(0)
  for i in p:
    if(i==' '):
      c=c+1
  for i in range(c):
    p.remove(' ')

  return p

customer_formats={}
def hybrid_recommendation(n_recommendations=5, content_weight=0.5):
    recommendations = {}
    unique_customer_ids = df['customer_id'].unique()
    for customer_id in unique_customer_ids:
        customer_data = df[df['customer_id'] == customer_id]

        # Content-Based Recommendations
        customer_profile = ' '.join(customer_data['categories'])
        customer_feature = tfidf_vectorizer.transform([customer_profile])

        content_indices = cosine_similarity(customer_feature, product_features).argsort()[0][-n_recommendations:]
        distances, indices = knn_model.kneighbors(pivot_table.loc[customer_id].values.reshape(1, -1), n_neighbors=n_recommendations)
        collaborative_indices = indices.squeeze()


        hybrid_indices = list(set(content_indices) | set(collaborative_indices))
        hybrid_scores = [(idx, content_weight * cosine_similarity(product_features[idx], customer_feature) + (1 - content_weight) * distance) for idx, distance in zip(hybrid_indices, distances.squeeze())]
        hybrid_scores.sort(key=lambda x: x[1], reverse=True)
        hybrid_recommendations = [df.loc[idx, 'Product_Type_ID'] for idx, _ in hybrid_scores]

        recommendations[customer_id] = hybrid_recommendations[:n_recommendations]

        x=[]
        for i in hybrid_recommendations:
          x.append(product_id(i))

        x=remove_space(x)
        customer_formats[customer_id] = x

hybrid_recommendation()

"""Providing Recommendations to Unique Customers using Customer_ID"""

def find_products(id):
  #hybrid_recommendation()
  return(customer_formats[id])

products=df['name']
categories=df['categories']

data={"Category":categories, "Product_Name":products}
ab = pd.DataFrame.from_dict(data)

def delete_file_contents(filename):
    with open(filename, 'w', newline='') as csvfile:
        csvfile.truncate(0)  # Truncate the file to delete its contents

filename = '/content/drive/MyDrive/Colab Notebooks/Capstone_Project/static/ProductRecommendations.csv'
def generate_product(id):
    delete_file_contents(filename)
    p = []
    p = find_products(id)
    ms=set()
    for i in p:
      ms.add(str(i))

    #p = set((p))  # Remove duplicates while maintaining order
    print("Recommended Categories:", ms)

    prod = []
    s=set()
    for category in p:
      for value in category:
        category_products = ab.loc[ab['Category'] == value, 'Product_Name']

        random_values = category_products.sample(n=5, replace=True)  # Sample with replacement to ensure same number of products
        for product in random_values:
            prod.append(product)
            s.add(product)
    # print("Recommended Products:", prod)

    my_list = list(s)

# Create a DataFrame from the list
    d = pd.DataFrame(my_list, columns=['RProducts'])

# Save the DataFrame to a file (e.g., CSV)
    d.to_csv( '/content/drive/MyDrive/Colab Notebooks/Capstone_Project/static/ProductRecommendations.csv', index=False)

    return s



